# -*- coding: utf-8 -*-
"""py_collections_lists_tuples.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Zn6ymIQi8fgT7Vy5ooei_WRRc7wTUliV

# Listas e Operacoes
"""

age_01 = 39
age_02 = 30
age_03 = 27
age_04 = 18

print(age_01)
print(age_02)
print(age_03)
print(age_04)

ages = [39, 30, 27, 18]
type(ages)

len(ages)

ages[0]

ages

ages.append(15)

ages

ages[4]

for age in ages:
  print(age)

ages.remove(30)

ages

ages.append(15)

ages

ages.remove(15)

ages

ages.append(27)
ages.remove(27)
ages

28 in ages

15 in ages

if 15 in ages:
  ages.remove(15)

ages

ages.clear()
ages

ages = [39, 18, 15, 27]
ages

"""*Adicionando elementos em uma lista :*

```
# Adicionando 1 elemento em 1 posicao 
```
"""

ages.insert(0, 20)
ages

"""

```
# Adicionando varios elementos em 1 lista, ou elementos de uma lista em outra lista.
```

"""

new_ages = [19, 21, 40]
ages.extend(new_ages)
ages

"""
```
# Descobrindo idades do proximo ano
```
"""

ages_next_year = []
for age in ages:
    ages_next_year.append(age + 1)
ages_next_year

"""

```
# List comprehension
```

"""

ages_next_year = [(age + 1) for age in ages]
ages_next_year

[(age) for age in ages if age > 21]

def next_year(age):
  return age + 1

[next_year(age) for age in ages if age > 21]

"""# Tuplas"""

class CorrentAccount:

  def __init__(self, code):
    self.code = code
    self.balance = 0

  def deposit(self, value):
    self.balance += value
  
  def __str__(self):
    return (f" Code: {self.code} >> Balance: {self.balance}")

account_01 = CorrentAccount(15)
print(account_01)

account_02 = CorrentAccount(5121)
print(account_02)

accounts = [account_01, account_02]
print(accounts)

for account in accounts:
  print(account)

account_01.deposit(100)
account_02.deposit(500)

for account in accounts:
  print(account)

def deposit_for_all_accounts(accounts):
  for account in accounts:
    account.deposit(100)

accounts = [account_01, account_02]
print(accounts[0], accounts[1])
deposit_for_all_accounts(accounts)
print(accounts[0], accounts[1])

"""
```
# Para sequencia de elementos com tipos diferentes que nao sao mutaveis ultilizamos tupla. (posicao especificas, coisas diferentes)
```

"""

igor = ('Igor', 20, 2000)  # tupla
amanda = ('Amanda', 20, 2001)

# Paulo = (39, 'Paulo', 1998) # ruim

igor.append(5123)

account_01 = (15, 1000)
# account_01.deposit() # variacao OO

print(account_01[1])

account_01[1] += 10

def deposit(account): # Modelo Procedural (Separando comportamento dos dados)
  new_balance = account[1] + 100
  code = account_01[0]
  return (code, new_balance)

account_01

account_01 = deposit(account_01)
account_01

users = [igor, amanda]
users

users.append(('Paulo', 21, 1999))
users

account_01 = CorrentAccount(15)

accounts = (account_01, account_02) # tuplas de objetos (podemos mudar o objeto, mas a tupla nao)

for account in accounts:
  print(account)

accounts[1].deposit(500)

accounts

for account in accounts:
  print(account)

"""# Polimorfismo e arrays

#### Heranca e polimorfismo
"""

class Account:

  def __init__(self, code):
    self._code = code
    self._balance = 0

  def deposit(self, value):
    self._balance += value
  
  def __str__(self):
    return (f" Code: {self._code} >> Balance: {self._balance}")

print(Account(88))

class CorrentAccount(Account):

  def spend_month(self):
    self._balance -= 2

class SavingsAccount(Account):
  
  def spend_month(self):
    self._balance *= 1.01
    self._balance -= 3

account_16 = CorrentAccount(16)
account_16.deposit(1000)
account_16.spend_month()
print(account_16)

account_17 = SavingsAccount(17)
account_17.deposit(2000)
account_17.spend_month()
print(account_17)

account_16 = CorrentAccount(16)
account_16.deposit(1000)
account_17 = SavingsAccount(17)
account_17.deposit(2000)
accounts = [account_16, account_17]

for account in accounts:
  account.spend_month() # Duck Typing
  print(account)

"""#### Array ( Evitaremos ultilizar )

"""

import array as arr

arr.array('d', [1, 3.5])

"""Onde seria viável utilizarmos o array, existe uma biblioteca que consegue ser mais recomendada para realização da tarefa, como trabalhar com números e dados matemáticos específicos, estamos falando da biblioteca *numpy*, **bastante utilizada na área de data science.**




```
import numpy as np
```


"""

import numpy as np

numbers = np.array([1, 3.5])
numbers

numbers + 3

"""

#### Metodo Abstrato
"""

class Account:

  def __init__(self, code):
    self._code = code
    self._balance = 0

  def deposit(self, value):
    self._balance += value
  
  def __str__(self):
    return (f" Code: {self._code} >> Balance: {self._balance}")

class CorrentAccount(Account):

  def spend_month(self):
    self._balance -= 2

class SavingsAccount(Account):
  
  def spend_month(self):
    self._balance *= 1.01
    self._balance -= 3

class InvestementAccount(Account):
  pass

InvestementAccount(600)

"""Foi possível criar uma conta investimento mesmo sem ter o método de passar o mês **spend_month**, mas para forçar toda conta que será herdeira da classe *Account* a ter esse método devemos utilizar o *abstractMethod*

OU SEJA, QUER FORCAR AS CLASSE TUDO QUE HERDA DA MAE TER O METODO X? SO COLOCA O METODO COMO METODO ABSTRATO, TAAAAAAAA?

```
import abc from ABCMeta, abstractmethod
```


"""

from abc import ABCMeta, abstractmethod

class Account(metaclass=ABCMeta):

  def __init__(self, code):
    self._code = code
    self._balance = 0

  def deposit(self, value):
    self._balance += value
  
  @abstractmethod
  def spend_month(self):
    pass

  def __str__(self):
    return (f" Code: {self._code} >> Balance: {self._balance}")

class CorrentAccount(Account):

  def spend_month(self):
    self._balance -= 2

class SavingsAccount(Account):
  
  def spend_month(self):
    self._balance *= 1.01
    self._balance -= 3

class InvestementAccount(Account):
  pass

print(Account(17))

print(InvestementAccount(20))

CorrentAccount(100)

SavingsAccount(131)



"""# Igualdade

#### Igualdade e o `__eq__`
"""

class SalaryAccount:

  def __init__(self, code):
    self._code = code
    self._balance = 0

  def deposit(self, value):
    self._balance += value

  def __str__(self):
    return (f" Code: {self._code} >> Balance: {self._balance}")

account_01 = SalaryAccount(37)
print(account_01)

account_02 = SalaryAccount(37)
print(account_02)

account_01 == account_02

accounts = [account_01]
account_01 in accounts

account_02 in accounts

class SalaryAccount:

  def __init__(self, code):
    self._code = code
    self._balance = 0

  def __eq__(self, other):
    return (self._code == other._code)

  def deposit(self, value):
    self._balance += value

  def __str__(self):
    return (f" Code: {self._code} >> Balance: {self._balance}")

account_01 = SalaryAccount(37)

account_02 = SalaryAccount(37)

account_01 == account_02

account_01 != account_02

account_01 in [account_02]

account_02 in [account_01]

class SalaryAccount:

  def __init__(self, code):
    self._code = code
    self._balance = 0

  def __eq__(self, other):
    return (self._code == other._code) and (self._balance == other._balance)

  def deposit(self, value):
    self._balance += value

  def __str__(self):
    return (f" Code: {self._code} >> Balance: {self._balance}")

account_01 = SalaryAccount(37)
account_02 = SalaryAccount(37)

account_01.deposit(10)

account_01 == account_02

class SalaryAccount:

  def __init__(self, code):
    self._code = code
    self._balance = 0

  def __eq__(self, other):
    if type(other) != SalaryAccount:
      return False

    return (self._code == other._code) and (self._balance == other._balance)

  def deposit(self, value):
    self._balance += value

  def __str__(self):
    return (f" Code: {self._code} >> Balance: {self._balance}")

account_01 = SalaryAccount(37)
account_02 = CorrentAccount(37)

account_01 == account_02

isinstance(CorrentAccount(37), CorrentAccount)

isinstance(CorrentAccount(37), Account)



"""# Outros Builtins

#### Builtins como enumerated, range e desempacotamento automatico de tuplas
"""

ages = [15, 87, 65, 56, 32, 49, 37]

"""


```
# Imprimindo a posicao e o elemento da lista
```

"""

range(len(ages))

for i  in range(len(ages)):
  print(i, ages[i])

enumerate(ages)

"""

```
# forcando a geracao de valores de uma vez
```
"""

list(range(len(ages)))

list(enumerate(ages))

"""

```
# Unpacking da nossa tupla
```

"""

for index, age in enumerate(ages):
  print(index, "x", age)

users = [
  ("Guilherme", 37, 1981),
  ("Igor", 20, 2000),
  ("Amanda", 19, 2001)
]

for name, age, birth in users: # Unpacking
  print(name)

for name, _, _ in users: # ignorando alguns elemntos com _, parecido com Haskell map
  print(name)

"""# Ordem Natural"""

ages = [15, 87, 65, 56, 32, 49, 37]

sorted(ages) # Ordenando as idades em ordem crescente (copia)

list(reversed(ages)) # printando a idade com os elementos ao contrario (copia)

sorted(ages, reverse=True) # Ordenando em ordem decrescente, (copia)

ages.sort() # Ordenando ordem crescente, (memoria)
ages

"""# Ordenacao Customizada


"""

names = ["Igor", "Amanda", "Mel"]
sorted(names)

names = ["Igor", "amanda", "Mel"] # Maiscula tem prioridade
sorted(names)

class SalaryAccount:

  def __init__(self, code):
    self._code = code
    self._balance = 0

  def __eq__(self, other):
    if type(other) != SalaryAccount:
      return False

    return (self._code == other._code) and (self._balance == other._balance)

  def deposit(self, value):
    self._balance += value

  def __str__(self):
    return (f" Code: {self._code} >> Balance: {self._balance}")

igor_account = SalaryAccount(10)
igor_account.deposit(500)

amanda_account = SalaryAccount(20)
amanda_account.deposit(1000)

mel_account = SalaryAccount(30)
mel_account.deposit(420)

accounts = [igor_account, amanda_account, mel_account]

for account in accounts:
    print(account)

sorted(accounts)

igor_account < amanda_account

def extract_balance(account):
    return account._balance

for account in sorted(accounts, key=extract_balance):
    print(account)

# attrgetter, ajuda a pegar um atributo

from operator import attrgetter

for account in sorted(accounts, key=attrgetter("_code", "_balance")):
    print(account)

igor_account < amanda_account

class SalaryAccount:

  def __init__(self, code):
    self._code = code
    self._balance = 0

  def __eq__(self, other):
    if type(other) != SalaryAccount:
      return False

    return (self._code == other._code) and (self._balance == other._balance)

  def __lt__(self, other): # Comparacao {less than}
    return self._balance < other._balance

  def deposit(self, value):
    self._balance += value

  def __str__(self):
    return (f" Code: {self._code} >> Balance: {self._balance}")

igor_account < amanda_account

igor_account = SalaryAccount(10)
igor_account.deposit(500)

amanda_account = SalaryAccount(20)
amanda_account.deposit(1000)

mel_account = SalaryAccount(30)
mel_account.deposit(420)

accounts = [igor_account, amanda_account, mel_account]

igor_account < amanda_account

amanda_account < igor_account

class SalaryAccount:

  def __init__(self, code):
    self._code = code
    self._balance = 0

  def __eq__(self, other):
    if type(other) != SalaryAccount:
      return False

    return (self._code == other._code) and (self._balance == other._balance)

  def __lt__(self, other): # Comparacao {less than}
    if self._balance != other._balance: 
        return self._balance < other._balance
        
    return self._code < other._code

  def deposit(self, value):
    self._balance += value

  def __str__(self):
    return (f" Code: {self._code} >> Balance: {self._balance}")

igor_account = SalaryAccount(10)
igor_account.deposit(1000)

amanda_account = SalaryAccount(20)
amanda_account.deposit(500)

mel_account = SalaryAccount(30)
mel_account.deposit(1000)

accounts = [igor_account, amanda_account, mel_account]

for account in sorted(accounts):
    print(account)

igor_account <= amanda_account

""" 
Para tratar todas as comparacoes importamos total_ordering do fuctools, mas
primeiro devemos implementar o metodo __eq__ e outro metodo de comparacao, 
entre eles __lt__, __le__.

"""

from functools import total_ordering

@total_ordering
class SalaryAccount:

  def __init__(self, code):
    self._code = code
    self._balance = 0

  def __eq__(self, other):
    if type(other) != SalaryAccount:
      return False

    return (self._code == other._code) and (self._balance == other._balance)

  def __lt__(self, other): # Comparacao {less than}
    if self._balance != other._balance: 
        return self._balance < other._balance
        
    return self._code < other._code

  def deposit(self, value):
    self._balance += value

  def __str__(self):
    return (f" Code: {self._code} >> Balance: {self._balance}")

igor_account = SalaryAccount(10)
igor_account.deposit(1000)

amanda_account = SalaryAccount(20)
amanda_account.deposit(500)

mel_account = SalaryAccount(30)
mel_account.deposit(1000)

accounts = [igor_account, amanda_account, mel_account]

igor_account <= amanda_account